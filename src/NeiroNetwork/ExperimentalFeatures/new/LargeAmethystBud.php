<?php

declare(strict_types=1);

namespace NeiroNetwork\ExperimentalFeatures\new;

use NeiroNetwork\ExperimentalFeatures\new\interface\IBlock;
use pocketmine\block\Block;
use pocketmine\block\BlockBreakInfo;
use pocketmine\block\BlockIdentifier;
use pocketmine\block\BlockToolType;
use pocketmine\block\Transparent;
use pocketmine\block\utils\AnyFacingTrait;
use pocketmine\block\utils\BlockDataSerializer;
use pocketmine\item\Item;
use pocketmine\item\ToolTier;
use pocketmine\math\Facing;
use pocketmine\math\Vector3;
use pocketmine\player\Player;
use pocketmine\world\BlockTransaction;

class LargeAmethystBud extends Feature implements IBlock{

	public function networkId() : int{
		return -330;
	}

	public function name() : string{
		return "large_amethyst_bud";
	}

	public function block() : Block{
		return new class(
			new BlockIdentifier($this->internalId(), 0, $this->internalId()),
			"Large Amethyst Bud",
			new BlockBreakInfo(1.5, BlockToolType::PICKAXE, ToolTier::WOOD()->getHarvestLevel())
		) extends Transparent{
			use AnyFacingTrait;

			protected function recalculateCollisionBoxes() : array{
				return parent::recalculateCollisionBoxes(); // TODO: Change the autogenerated stub
			}

			protected function writeStateToMeta() : int{
				return BlockDataSerializer::writeFacing($this->facing);
			}

			public function readStateFromData(int $id, int $stateMeta) : void{
				$this->facing = BlockDataSerializer::readFacing($stateMeta);
			}

			public function place(BlockTransaction $tx, Item $item, Block $blockReplace, Block $blockClicked, int $face, Vector3 $clickVector, ?Player $player = null) : bool{
				if($player !== null){
					if(abs($player->getPosition()->getX() - $this->position->getX()) < 2 && abs($player->getPosition()->getZ() - $this->position->getZ()) < 2){
						$y = $player->getEyePos()->getY();

						if($y - $this->position->getY() > 2){
							$this->facing = Facing::UP;
						}elseif($this->position->getY() - $y > 0){
							$this->facing = Facing::DOWN;
						}else{
							$this->facing = Facing::opposite($player->getHorizontalFacing());
						}
					}else{
						$this->facing = Facing::opposite($player->getHorizontalFacing());
					}
				}

				return parent::place($tx, $item, $blockReplace, $blockClicked, $face, $clickVector, $player);
			}
		};
	}
}